#version 430
#extension GL_GOOGLE_include_directive : enable

#define WIRE_STEP
#include "common.comp"

void enqueue_driving(Wire wire) {
    uint next_driving = wire.first_driving;
    while (next_driving != INVALID_INDEX) {
        WireDriving driving = wire_driving[next_driving];
        next_driving = driving.next_driving;

        uint update_queue_index = atomicAdd(component_update_queue_index, 1);
        if (update_queue_index < component_update_queue.length()) {
            component_update_queue[update_queue_index] = driving.component_id;
        } else {
            atomicOr(list_flags, LIST_FLAGS_COMPONENT_UPDATE_QUEUE_OVERFLOW);
        }
    }
}

void mark_conflict(uint wire_index) {
    uint list_index = atomicAdd(conflict_list_index, 1);
    if (list_index < conflict_list.length()) {
        conflict_list[list_index] = wire_index;
    } else {
        atomicOr(list_flags, LIST_FLAGS_CONFLICT_LIST_OVERFLOW);
    }
}

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
void main() {
    uint queue_index = atomicAdd(wire_update_queue_index, 1);
    if (queue_index >= wire_update_queue_len) {
        return;
    }

    uint wire_index = wire_update_queue[queue_index];
    Wire wire = wires[wire_index];

    WireStateAtom new_state[MAX_STATE_LEN];
    for (uint bit_index = 0; bit_index < wire.width; bit_index += 32) {
        uint index = bit_index / 32;
        new_state[index] = WireStateAtom(wire_drives[wire.drive_offset + index], 0);
    }

    uint next_driver = wire.first_driver;
    while (next_driver != INVALID_INDEX) {
        WireDriver driver = wire_drivers[next_driver];
        next_driver = driver.next_driver;

        for (uint bit_index = 0; bit_index < wire.width; bit_index += 32) {
            uint index = bit_index / 32;

            LogicStateAtom output_state = output_states[driver.output_state_offset + index];
            new_state[index] = combine_state(new_state[index], output_state);
        }
    }

    bool state_changed = false;
    bool has_conflict = false;
    for (uint bit_index = 0; bit_index < wire.width; bit_index += 32) {
        uint index = bit_index / 32;

        if (!logic_state_equal(wire_states[wire.state_offset + index], new_state[index].state)) {
            wire_states[wire.state_offset + index] = new_state[index].state;
            state_changed = true;
        }

        if (new_state[index].conflict != 0) {
            has_conflict = true;
        }
    }

    if (state_changed) {
        enqueue_driving(wire);
    }

    if (has_conflict) {
        mark_conflict(wire_index);
    }
}
