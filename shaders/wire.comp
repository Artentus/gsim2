#version 430
#extension GL_GOOGLE_include_directive : enable

#define WIRE_STEP
#include "common.comp"

void mark_conflict(uint wire_index) {
    uint list_index = atomicAdd(conflict_list_len, 1);
    if (list_index < conflict_list.length()) {
        conflict_list[list_index] = wire_index;
    }
}

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
void main() {
    uint wire_index = gl_GlobalInvocationID.x;
    if (wire_index >= wires.length()) return;
    Wire wire = wires[wire_index];

    WireStateAtom new_state[MAX_STATE_LEN];
    for (uint bit_index = 0; bit_index < wire.width; bit_index += 32) {
        uint index = bit_index / 32;
        new_state[index] = WireStateAtom(wire_drives[wire.drive_offset + index], 0);
    }

    uint next_driver = wire.first_driver;
    while (next_driver != INVALID_INDEX) {
        WireDriver driver = wire_drivers[next_driver];
        next_driver = driver.next_driver;

        for (uint bit_index = 0; bit_index < wire.width; bit_index += 32) {
            uint index = bit_index / 32;

            LogicStateAtom output_state = output_states[driver.output_state_offset + index];
            new_state[index] = combine_state(new_state[index], output_state);
        }
    }

    bool state_changed = false;
    bool has_conflict = false;
    for (uint bit_index = 0; bit_index < wire.width; bit_index += 32) {
        uint index = bit_index / 32;

        if (!logic_state_equal(wire_states[wire.state_offset + index], new_state[index].state)) {
            wire_states[wire.state_offset + index] = new_state[index].state;
            state_changed = true;
        }

        if (new_state[index].conflict != 0) {
            has_conflict = true;
        }
    }

    if (state_changed) {
        atomicAdd(changed_count, 1);
    }

    if (has_conflict) {
        mark_conflict(wire_index);
    }
}
