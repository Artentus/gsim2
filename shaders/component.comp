#version 430
#extension GL_GOOGLE_include_directive : enable

#define COMPONENT_STEP
#include "common.comp"

bool gate_impl(Component component) {
    LogicStateAtom new_state[MAX_STATE_LEN];
    ComponentOutput c_output = outputs[component.first_output];

    ComponentInput first_input = inputs[component.first_input];
    for (uint bit_index = 0; bit_index < c_output.width; bit_index += 32) {
        uint index = bit_index / 32;

        if (bit_index < first_input.width) {
            new_state[index] = wire_states[first_input.wire_state_offset + index];
        } else {
            new_state[index] = HIGH_Z;
        }
    }

    uint next_input = first_input.next_input;
    while (next_input != INVALID_INDEX) {
        ComponentInput c_input = inputs[next_input];
        next_input = c_input.next_input;

        for (uint bit_index = 0; bit_index < c_output.width; bit_index += 32) {
            uint index = bit_index / 32;

            LogicStateAtom input_atom;
            if (bit_index < c_input.width) {
                input_atom = wire_states[c_input.wire_state_offset + index];
            } else {
                input_atom = HIGH_Z;
            }

            switch (component.kind) {
                case COMPONENT_KIND_AND: {
                    new_state[index] = logic_and(new_state[index], input_atom);
                    break;
                }
                case COMPONENT_KIND_OR: {
                    new_state[index] = logic_or(new_state[index], input_atom);
                    break;
                }
                case COMPONENT_KIND_XOR: {
                    new_state[index] = logic_xor(new_state[index], input_atom);
                    break;
                }
                case COMPONENT_KIND_NAND: {
                    new_state[index] = logic_nand(new_state[index], input_atom);
                    break;
                }
                case COMPONENT_KIND_NOR: {
                    new_state[index] = logic_nor(new_state[index], input_atom);
                    break;
                }
                case COMPONENT_KIND_XNOR: {
                    new_state[index] = logic_xnor(new_state[index], input_atom);
                    break;
                }
                default: {
                    break;
                }
            }
        }
    }

    bool state_changed = false;
    for (uint bit_index = 0; bit_index < c_output.width; bit_index += 32) {
        uint index = bit_index / 32;

        if (!logic_state_equal(output_states[c_output.state_offset + index], new_state[index])) {
            output_states[c_output.state_offset + index] = new_state[index];
            state_changed = true;
        }
    }

    return state_changed;
}

bool not_impl(Component component) {
    ComponentOutput c_output = outputs[component.first_output];
    ComponentInput c_input = inputs[component.first_input];

    bool state_changed = false;
    for (uint bit_index = 0; bit_index < c_output.width; bit_index += 32) {
        uint index = bit_index / 32;

        LogicStateAtom atom = logic_not(wire_states[c_input.wire_state_offset + index]);
        if (!logic_state_equal(output_states[c_output.state_offset + index], atom)) {
            output_states[c_output.state_offset + index] = atom;
            state_changed = true;
        }
    }

    return state_changed;
}

bool buffer_impl(Component component) {
    return false;
}

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
void main() {
    uint component_index = gl_GlobalInvocationID.x;
    if (component_index >= components.length()) return;
    Component component = components[component_index];

    bool state_changed;
    switch (component.kind) {
        case COMPONENT_KIND_AND:
        case COMPONENT_KIND_OR:
        case COMPONENT_KIND_XOR:
        case COMPONENT_KIND_NAND:
        case COMPONENT_KIND_NOR:
        case COMPONENT_KIND_XNOR: {
            state_changed = gate_impl(component);
            break;
        }
        case COMPONENT_KIND_NOT: {
            state_changed = not_impl(component);
            break;
        }
        case COMPONENT_KIND_BUFFER: {
            state_changed = buffer_impl(component);
            break;
        }
        default: {
            state_changed = false;
            break;
        }
    }

    if (state_changed) {
        atomicAdd(changed_count, 1);
    }
}
