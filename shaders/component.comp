#version 430
#extension GL_GOOGLE_include_directive : enable

#define COMPONENT_STEP
#include "common.comp"

void enqueue_output(ComponentOutput c_output) {
    uint update_queue_index = atomicAdd(wire_update_queue_index, 1);
    if (update_queue_index < wire_update_queue.length()) {
        wire_update_queue[update_queue_index] = c_output.wire_id;
    } else {
        atomicOr(list_flags, LIST_FLAGS_WIRE_UPDATE_QUEUE_OVERFLOW);
    }
}

void gate_impl(Component component) {
    LogicStateAtom new_state[MAX_STATE_LEN];
    ComponentOutput c_output = outputs[component.first_output];

    ComponentInput first_input = inputs[component.first_input];
    for (uint bit_index = 0; bit_index < c_output.width; bit_index += 32) {
        uint index = bit_index / 32;

        if (bit_index < first_input.width) {
            new_state[index] = wire_states[first_input.wire_state_offset + index];
        } else {
            new_state[index] = HIGH_Z;
        }
    }

    uint next_input = first_input.next_input;
    while (next_input != INVALID_INDEX) {
        ComponentInput c_input = inputs[next_input];
        next_input = c_input.next_input;

        for (uint bit_index = 0; bit_index < c_output.width; bit_index += 32) {
            uint index = bit_index / 32;

            LogicStateAtom input_atom;
            if (bit_index < c_input.width) {
                input_atom = wire_states[c_input.wire_state_offset + index];
            } else {
                input_atom = HIGH_Z;
            }

            switch (component.kind) {
                case COMPONENT_KIND_AND: {
                    new_state[index] = logic_and(new_state[index], input_atom);
                    break;
                }
                case COMPONENT_KIND_OR: {
                    new_state[index] = logic_or(new_state[index], input_atom);
                    break;
                }
                case COMPONENT_KIND_XOR: {
                    new_state[index] = logic_xor(new_state[index], input_atom);
                    break;
                }
                case COMPONENT_KIND_NAND: {
                    new_state[index] = logic_nand(new_state[index], input_atom);
                    break;
                }
                case COMPONENT_KIND_NOR: {
                    new_state[index] = logic_nor(new_state[index], input_atom);
                    break;
                }
                case COMPONENT_KIND_XNOR: {
                    new_state[index] = logic_xnor(new_state[index], input_atom);
                    break;
                }
                default: {
                    break;
                }
            }
        }
    }

    bool state_changed = false;
    for (uint bit_index = 0; bit_index < c_output.width; bit_index += 32) {
        uint index = bit_index / 32;

        if (!logic_state_equal(output_states[c_output.state_offset + index], new_state[index])) {
            output_states[c_output.state_offset + index] = new_state[index];
            state_changed = true;
        }
    }

    if (state_changed) {
        enqueue_output(c_output);
    }
}

void not_impl(Component component) {
    ComponentOutput c_output = outputs[component.first_output];
    ComponentInput c_input = inputs[component.first_input];

    bool state_changed = false;
    for (uint bit_index = 0; bit_index < c_output.width; bit_index += 32) {
        uint index = bit_index / 32;

        LogicStateAtom atom = logic_not(wire_states[c_input.wire_state_offset + index]);
        if (!logic_state_equal(output_states[c_output.state_offset + index], atom)) {
            output_states[c_output.state_offset + index] = atom;
            state_changed = true;
        }
    }

    if (state_changed) {
        enqueue_output(c_output);
    }
}

void buffer_impl(Component component) {

}

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
void main() {
    uint queue_index = atomicAdd(component_update_queue_index, 1);
    if (queue_index >= component_update_queue_len) {
        return;
    }

    uint component_index = component_update_queue[queue_index];
    Component component = components[component_index];

    switch (component.kind) {
        case COMPONENT_KIND_AND:
        case COMPONENT_KIND_OR:
        case COMPONENT_KIND_XOR:
        case COMPONENT_KIND_NAND:
        case COMPONENT_KIND_NOR:
        case COMPONENT_KIND_XNOR: {
            gate_impl(component);
            break;
        }
        case COMPONENT_KIND_NOT: {
            not_impl(component);
            break;
        }
        case COMPONENT_KIND_BUFFER: {
            buffer_impl(component);
            break;
        }
        default: {
            break;
        }
    }
}
