#version 430
#extension GL_GOOGLE_include_directive : enable

#define COMPONENT_STEP
#include "common.comp"

bool gate_impl(Component component) {
    LogicStateAtom new_state[MAX_STATE_LEN];
    ComponentOutput c_output = outputs[component.first_output];

    ComponentInput first_input = inputs[component.first_input];
    for (uint bit_index = 0; bit_index < c_output.width; bit_index += 32) {
        uint index = bit_index / 32;

        if (bit_index < first_input.width) {
            new_state[index] = wire_states[first_input.wire_state_offset + index];
        } else {
            new_state[index] = HIGH_Z;
        }
    }

    for (uint input_index = 0; input_index < component.input_count; input_index++) {
        ComponentInput c_input = inputs[component.first_input + input_index];

        for (uint bit_index = 0; bit_index < c_output.width; bit_index += 32) {
            uint index = bit_index / 32;

            LogicStateAtom input_atom;
            if (bit_index < c_input.width) {
                input_atom = wire_states[c_input.wire_state_offset + index];
            } else {
                input_atom = HIGH_Z;
            }

            switch (component.kind) {
                case COMPONENT_KIND_AND: {
                    new_state[index] = logic_and(new_state[index], input_atom);
                    break;
                }
                case COMPONENT_KIND_OR: {
                    new_state[index] = logic_or(new_state[index], input_atom);
                    break;
                }
                case COMPONENT_KIND_XOR: {
                    new_state[index] = logic_xor(new_state[index], input_atom);
                    break;
                }
                case COMPONENT_KIND_NAND: {
                    new_state[index] = logic_nand(new_state[index], input_atom);
                    break;
                }
                case COMPONENT_KIND_NOR: {
                    new_state[index] = logic_nor(new_state[index], input_atom);
                    break;
                }
                case COMPONENT_KIND_XNOR: {
                    new_state[index] = logic_xnor(new_state[index], input_atom);
                    break;
                }
                default: {
                    break;
                }
            }
        }
    }

    bool state_changed = false;
    for (uint bit_index = 0; bit_index < c_output.width; bit_index += 32) {
        uint index = bit_index / 32;

        if (!logic_state_equal(output_states[c_output.state_offset + index], new_state[index])) {
            output_states[c_output.state_offset + index] = new_state[index];
            state_changed = true;
        }
    }

    return state_changed;
}

bool not_impl(Component component) {
    ComponentOutput c_output = outputs[component.first_output];
    ComponentInput c_input = inputs[component.first_input];

    bool state_changed = false;
    for (uint bit_index = 0; bit_index < c_output.width; bit_index += 32) {
        uint index = bit_index / 32;

        LogicStateAtom atom;
        if (bit_index < c_input.width) {
            atom = wire_states[c_input.wire_state_offset + index];
        } else {
            atom = HIGH_Z;
        }
        atom = logic_not(atom);

        if (!logic_state_equal(output_states[c_output.state_offset + index], atom)) {
            output_states[c_output.state_offset + index] = atom;
            state_changed = true;
        }
    }

    return state_changed;
}

bool buffer_impl(Component component) {
    ComponentOutput c_output = outputs[component.first_output];
    ComponentInput c_input = inputs[component.first_input];
    ComponentInput c_enable = inputs[component.first_output + 1];

    LogicStateAtom enable = wire_states[c_enable.wire_state_offset];
    bool enable_state = (enable.state & 0x1) > 0;
    bool enable_valid = (enable.valid & 0x1) > 0;

    bool state_changed = false;
    for (uint bit_index = 0; bit_index < c_output.width; bit_index += 32) {
        uint index = bit_index / 32;

        LogicStateAtom atom;
        if (!enable_valid) {
            atom = UNDEFINED;
        } else if ((enable_state) && (bit_index < c_input.width)) {
            atom = wire_states[c_input.wire_state_offset + index];
        } else {
            atom = HIGH_Z;
        }

        if (!logic_state_equal(output_states[c_output.state_offset + index], atom)) {
            output_states[c_output.state_offset + index] = atom;
            state_changed = true;
        }
    }

    return state_changed;
}

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
void main() {
    if (((changed & WIRE_STATES_CHANGED) == 0) || (conflict_list_len > 0)) return;

    uint component_index = gl_GlobalInvocationID.x;
    if (component_index >= components.length()) return;
    Component component = components[component_index];

    bool state_changed;
    switch (component.kind) {
        case COMPONENT_KIND_AND:
        case COMPONENT_KIND_OR:
        case COMPONENT_KIND_XOR:
        case COMPONENT_KIND_NAND:
        case COMPONENT_KIND_NOR:
        case COMPONENT_KIND_XNOR: {
            state_changed = gate_impl(component);
            break;
        }
        case COMPONENT_KIND_NOT: {
            state_changed = not_impl(component);
            break;
        }
        case COMPONENT_KIND_BUFFER: {
            state_changed = buffer_impl(component);
            break;
        }
        default: {
            state_changed = false;
            break;
        }
    }

    if (state_changed) {
        atomicOr(changed, COMPONENT_STATES_CHANGED);
    }
}
